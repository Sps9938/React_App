import React ,{useEffect} from "react";
import {useForm} from 'react-hook-form'

import {Button, Input, Select, RTE} from '../index'

import appwriteService from "../../appwrite/config";

import { useNavigate } from "react-router-dom";

import { useSelector } from  'react-redux'

export default function PostForm( { post }) {
    const { register, handleSubmit, watch, setValue, control, getValues } = useForm({
        defaultValues: {
            title: post?.title || "",
            slug: post?.$id || "",
            //if we have used mongoDb then you wrtie {
           //slug: post?._id 
            // }
            content: post?.content || "",
            status: post?.status || "active",
        },
    });
    const navigate = useNavigate();
    const userData = useSelector((state) => state.auth.userData);

    const submit = async (data) => {
        if(post) {

            const file = data.image[0] ? await appwriteService.uploadFile(data.image[0]) : null

            if(file) {
                appwriteService.deleteFile(post.featuredImage);
            }

            const dbPost = await appwriteService.updatePost(post.$id, {
            ...data,
            featuredImage: file ? file.$id : undefined,
            });
            
            if (dbPost) {
                navigate(`/post/${dbPost.$id}`)
            } 
        }
        else{
            const file = await appwriteService.uploadFile(data.image[0])

            if(file){
                const fileId = file.$id;
                data.featuredImage = fileId;
                const dbPost = await appwriteService.createPost({...data, userId: userData.$id});

    /*
        ðŸ“Œ What is Stored in dbPost?
        
        -> dbPost contains the response from appwriteService.createPost, which usually returns a document object stored in the Appwrite database.

        1. data (Spread Operator ...data)
        ...data spreads all existing key-value pairs from the data object into the new object passed to createPost().

        The data object likely contains:
        {
        title: "Post Title",
        content: "Post Content",
        featuredImage: "image_file_id",
        category: "Technology",
        createdAt: "2025-04-03T10:30:00Z"  // Example timestamp
        }

        explanation:->
        . title: Post title.

        . content: Post body/content.

        . featuredImage: The file ID of the uploaded image.

        . category: Post category.

        . createdAt: Automatically generated timestamp.

        2. userId: userData.$id
        userData.$id is the unique user ID from the authenticated user.

        This associates the post with the user who created it.

        Final Data Sent to createPost()
        After spreading data and adding userId, the final object passed to createPost() looks like this:

        {
        title: "Example Post",
        content: "This is the post content.",
        featuredImage: "63f8c5d1a5b5c", // File ID of uploaded image
        category: "Technology",
        createdAt: "2025-04-03T10:30:00Z",
    *-> userId: "user_abc123" // ID of the user who created the post
        }

        ðŸ“Œ What Does dbPost Contain After createPost()?

        When appwriteService.createPost() successfully creates the post, it typically returns the saved document from the Appwrite database. The dbPost response may look like this:

        {
        "$id": "post_xyz789",  // Unique post ID generated by Appwrite
        "title": "Example Post",
        "content": "This is the post content.",
        "featuredImage": "63f8c5d1a5b5c",  // File ID (used to retrieve image)
        "category": "Technology",
        "createdAt": "2025-04-03T10:30:00Z",
    *-> "userId": "user_abc123"
        }

    */
                if(dbPost) {
                    navigate(`/post/${dbPost.$id}`)
                }
            }
        }
    }

    const slugTransForm = useCallback((value) => {
        if(value && typeof value === "string")
            return value
            .trim()
            .toLowerCase()
            .replace(/[^a-zA-Z\d\s]+/g, "-")
            .replace(/\s/g, "-");

            return "";
        /*

        Q> What It Does:

        -> trim() â€“ Removes extra spaces from the start and end of the title.

        -> toLowerCase() â€“ Converts all characters to lowercase for consistency.

        -> replace(/[^a-zA-Z\d\s]+/g, "-") â€“ Replaces any non-alphanumeric characters (except spaces) with "-".

        -> replace(/\s/g, "-") â€“ Replaces all spaces with "-" to make it URL-friendly.


        Example Transformations:

        Title Input	        Slug Output

        "Hello World!"	    "hello-world"
        "React & Next.js"	 "react-next-js"
        " My First Post "	"my-first-post"
        
        Q> Why Do We Need This?

        1. SEO & URL-Friendly: Slugs are commonly used in URLs (example.com/blog/hello-world instead of example.com/blog/123).

        2. Consistency: Ensures all slugs follow the same pattern.

        3. Auto-Generation: Users don't need to manually enter a slug; it's created automatically from the title.


        */

    },[])


    useEffect(() => {
        const subScription = watch((value, { name }) => {
            if(name === "title") {
                setValue("slug", slugTransForm(value.title), { shouldValidate: true})
            }
        });
        /*
    Q> What Does It Do?

        -> watch() â€“ This is a function from        react-hook-form that listens to form field changes.

        -> if (name === "title") â€“ Checks if the changed field is "title".

        -> slugTransForm(value.title) â€“ Converts the title into a slug using the slugTransForm function.

        -> setValue("slug", ...) â€“ Updates the slug field dynamically based on the title input.

        -> Cleanup (unsubscribe()) â€“ Unsubscribes from watch() when the component unmounts to prevent memory leaks.

    Q> Why Do We Need This?

        -> Automatic Slug Generation: As the user types a title, the slug field updates in real time.

        -> Keeps UI in Sync: Ensures the slug field stays updated without needing extra user input.

        -> Memory Management: Prevents unnecessary re-renders and memory leaks by unsubscribing when the component unmounts.


        Example Flow
        
        1. User types: "Hello World"

        2. watch() detects the change in the title field.

        3. slugTransForm("Hello World") converts it to "hello-world".

        4. setValue("slug", "hello-world") updates the slug field in the form.

        5. If the component unmounts, unsubscribe() ensures watch() stops listening.

        */
        return () => subScription.unsubscribe()
        
    },[watch, slugTransForm, setValue]);


    return (
    <form onSubmit={handleSubmit(submit)} className="flex flex-wrap">
        <div className="w-2/3 px-2">
            <Input
                label="Title :"
                placeholder="Title"
                className="mb-4"
                {...register("title", { required: true })}
            />
            <Input
                label="Slug :"
                placeholder="Slug"
                className="mb-4"
                {...register("slug", { required: true })}
                onInput={(e) => {
                    setValue("slug", slugTransform(e.currentTarget.value), { shouldValidate: true });
                }}
            />
            <RTE label="Content :" name="content" control={control} defaultValue={getValues("content")} />
        </div>
        <div className="w-1/3 px-2">
            <Input
                label="Featured Image :"
                type="file"
                className="mb-4"
                accept="image/png, image/jpg, image/jpeg, image/gif"
                {...register("image", { required: !post })}
            />
            {post && (
                <div className="w-full mb-4">
                    <img
                        src={appwriteService.getFilePreview(post.featuredImage)}
                        alt={post.title}
                        className="rounded-lg"
                    />
                </div>
            )}
            <Select
                options={["active", "inactive"]}
                label="Status"
                className="mb-4"
                {...register("status", { required: true })}
            />
            <Button type="submit" bgColor={post ? "bg-green-500" : undefined} className="w-full">
                {post ? "Update" : "Submit"}
            </Button>
        </div>
    </form>
    );

}